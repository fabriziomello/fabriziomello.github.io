<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Partitioning | Fabrízio de Royes Mello]]></title>
  <link href="http://fabriziomello.github.io/blog/categories/partitioning/atom.xml" rel="self"/>
  <link href="http://fabriziomello.github.io/"/>
  <updated>2014-03-28T12:48:20-03:00</updated>
  <id>http://fabriziomello.github.io/</id>
  <author>
    <name><![CDATA[Fabrízio de Royes Mello]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PostgreSQL + Unlogged Tables + Partitioning + Parallel Programming = ETL Reescrito Passando De ~8h Para ~25min De Execução]]></title>
    <link href="http://fabriziomello.github.io/blog/2013/02/20/postgresql-unlogged-tables-partitioning/"/>
    <updated>2013-02-20T00:00:00-03:00</updated>
    <id>http://fabriziomello.github.io/blog/2013/02/20/postgresql-unlogged-tables-partitioning</id>
    <content type="html"><![CDATA[<div class='post'>
Já faz algum tempo que não escrevo nada por aqui, mas não é por falta de tempo ou coisa parecida, é que na realidade não tenho muita intimidade com artigos ou posts em blogs, mas resolvi escrever um "causo" a pedido do amigo <a href="http://www.fernandoike.com/">Fernando Ike</a> sobre um <a href="https://twitter.com/fabriziomello/status/295317858177658881">tweet</a> que lancei há algum tempo depois de obter sucesso em um projeto.<br /><br />Aviso antecipadamente que o post é um pouco longo, então se não estiver com paciência agora recomendo vc sair tomar um café (ou uma cerveja) e voltar outra hora... desculpe mesmo, tentei reduzir o máximo... :-(<br /><br /><h4>Contextualização</h4>Para vcs entenderem porque cheguei aqui, vou começar dos primórdios... eu tenho (ou tinha...hehehe...) um problema com um ETL em uma aplicação de um cliente (não tenho autorização para "dar nome aos bois") que basicamente processava os registros de uma grande tabela com dados financeiros e gerava uma "posição" da mesma calculando correção monetária, juros, multas, descontos, etc...<br /><br />Esse ETL sempre foi e ainda é ridiculamente simples, porque basicamente é uma PL/pgSQL dentro do PostgreSQL que faz todo esse trabalho de ler os dados de uma tabela, processar e carregar os mesmos em outra tabela. Até aqui tudo bem, sempre funcionou maravilhosamente bem, mas com bases pequenas... mas também não queremos maravilhas de desempenho processando milhares de registros em uma única transação né, é óbvio que isso gera problemas.<br /><br /><h4>Primeira tentativa... e um sucesso, digamos, opaco...</h4>Há alguns anos eu já tinha melhorado essa rotina dividindo o processamento em lotes menores, através de um shell script que fazia esse trabalho de divisão em lotes por uma coluna da tabela que categorizava os registros em um determinado tipo, então primeiro identificamos os tipos existentes na tabela origem e processava os mesmos gerando tabelas individuais para cada tipo, e ao final juntava tudo na tabela de destino e removia as tabelas temporárias... e vejam só, SEMPRE a MESMA tabela de destino, e para isso precisamos remover os índices, executar o ETL e depois criar novamente os índices para termos um desempenho decente. Claro que junto dessa rotina implementamos também uma outra para expurgo de registros desnecessários/obsoletos (antigos), o que também sempre foi uma rotina que onerava bastante o servidor pois era SEMPRE a MESMA tabela de destino, então imaginem precisar remover uma porção de registros de uma tabela com mais de 100milhões de registros... isso me lembra um post do <a href="http://tellesr.com/">Fábio Telles</a>: <a href="http://savepoint.blog.br/nao-use-delete-use-insert/">"Não use DELETE use INSERT"</a>&nbsp;que ajudou muito para torná-la "menos pior".<br /><br />Na época (2007/2008) essa melhoria ajudou pois desafogou bastante a carga de processamento desse ETL, porém com o passar do tempo e a tabela com dados financeiros crescendo constantemente, o ETL foi ficando cada vez mais oneroso chegando ao seu ápice (final de 2012) de ~8h de execução para processar ~8.5milhões de registros. Eu sei que esse número não é tão expressivo assim, mas a complexidade do processamento envolvido para fazer os cálculos de corrreção, juros e multas e as diversas configurações existentes para cada um justificam, de certa forma, todo esse tempode processamento, sem contar que o coitado do servidor ficava "imprestável".<br /><br />Mas vejam bem, estou falando de dados *financeiros* que sob ponto de vista do negócio se fazem muito necessários para vários tipos de procedimentos e análises. Ainda existem instâncias com bases menores (outros clientes) que rodam esse ETL _diariamente_ por necessidade de negócio, mas nesse cliente em especial não é possível fazer isso, nem que eles quisessem &nbsp;pois o tempo total de execução consume 1/3 de um dia, então os finais de semana são usados :-)<br /><br /><h4>A hora da verdade ...</h4>Após todos os problemas e sem muitas perspectivas, discutimos sobre a re-implementação da PL/pgSQL que executava o ETL, porém isso não é algo trivial, ainda mais em um ERP complexo onde tal iniciativa teria um impacto de grandes proporções visto que seria necessária uma re-modelagem em &nbsp;alguns pontos criticos. Apesar de ser uma idéia interessante, &nbsp;não existe tempo hábil para tanto, pois o cliente não pode mais aguardar uma solução, pois qto mais tempo demorar pior fica.<br /><br />Como eu já tenho algum tempo de estrada com PostgreSQL e conheço bem a estrtutura do ETL e do ERP em questão, sugeri a equipe que eu poderia re-implementar o antigo shell script reaproveitando a PL/pgSQL do ETL existente (sem mudar regras de negócio), usando tecnologias e técnicas conhecidas. Então o que fiz:<br /><br />1) Particionamento da tabela: esse foi o ponto fundamental, pois dividimos a grande tabela em outras menores tomando como base uma coluna que indica a "data" em que os dados financeiros foram calculados, e que o ERP usa constantemente para ler informações da mesma, portanto as queries iriam se beneficiar do recurso. Sobre esse assunto, além da <a href="http://www.postgresql.org/docs/current/static/ddl-partitioning.html">documentação oficial</a>, vcs podem dar uma olhada em <a href="http://savepoint.blog.br/?s=particionamento&amp;submit=Pesquisa">alguns artigos</a> recém lançados pelo <a href="http://tellesr.com/">Fábio Telles</a> sobre esse assunto.<br /><br />2) Implementação de um script PHP (não estou de sacanagem... é PHP mesmo, mas no console) que tivesse a habilidade de gerar processos filhos (fork) para processamento em paralelo, e para isso usei uma <a href="http://blog.motane.lu/2009/01/02/multithreading-in-php/">classe para realizar esse trabalho</a>. Confesso que no inicio tive um certo receio em implementar essa rotina em PHP, inclusive cogitei a possibilidade de fazê-la em Perl, Python ou Ruby, mas como eu domino mais esta do que as outras e o tempo era curto implementei nela mesmo, e os resultados foram muito satisfatórios.<br /><br /><br /><h4>COPY no lugar de INSERT</h4>A primeira coisa que fiz para continuar esse projeto foi *abolir* o INSERT... isso mesmo... não tem INSERT... vc deve estar pensando que estou maluco e se perguntando: "Tá e como adicionar linhas a uma tabela então?" R: usando <a href="http://www.postgresql.org/docs/current/static/sql-copy.html">COPY</a>, ao invés de INSERT... na realidade implementei uma classe que armazena uma coleção (linhas) em memória, e quando eu preciso uso um método para persistir os dados em uma tabela usando COPY... simples assim... então o código usado para INSERT é algo do tipo:<br /><br />DDL da tabela exemplo:<br /><pre class="brush: sql; toolbar: false">create table foo (<br />  bar integer<br />);<br /></pre><br />PHP:<br /><pre class="brush: php; toolbar: false">$tabela = new PgCopy('foo');<br />for ($i=0; $i<10; $i++) {<br />    $tabela->bar = $i;<br />    $tabela->insertValue(); // adiciona em memória<br />}<br />$tabela->persist(); // realiza COPY dos dados em memória<br /></pre><br /><br /><h4>Dividir para conquistar</h4>Um dos problemas que tinhamos com o processo antigo era justamente que ele era linear, ou seja, um processo apenas com inicio, meio e fim. Então resolvi investir em programação paralela, dividindo o grande volume de registros a processar em vários trabalhos menores sendo capaz de executar alguns em paralelo, de acordo com o nro de núcleos do servidor.<br /><br />Para tal atividades crio uma tabela que <b>planeja</b> a execução do trabalho, ou seja, cria lotes para que o script possa processar em paralelo, isso baseado em uma chave artifical (sequencial) que existe no modelo e facilitou a criação de trabalhos com lotes de N registros (neste caso usei 1000).<br /><br />A tabela que crio para planejar a execução do ETL é algo do tipo:<br /><pre class="brush: sql; toolbar: false">create table jobs (<br />  id_start bigint,<br />  id_end bigint,<br />  status varchar,<br />  constraint jobs_pk primary key (id_start, id_end),<br />  constraint jobs_status_ck check (status in ('NOT RUNNING', 'RUNNING', 'FINISHED'))<br />);<br /></pre><br />Dessa forma utilizo o "id_start" e "id_end" para buscar as informações na origem em "lotes" de 1000 (mil) registros, e com isso consigo disparar vários processos em paralelo, e dessa forma conseguimos aproveitar melhor os recursos do servidor e assim agilizar bastante o processo.<br /><br /><br /><h4>Unlogged Tables são bem legais</h4>Esse <a href="http://www.postgresql.org/docs/current/static/sql-createtable.html">novo recurso</a> presente apartir da <a href="http://www.postgresql.org/docs/current/interactive/release-9-1.html">versão 9.1</a> permite criar tabelas que não são escritas no <a href="http://www.postgresql.org/docs/current/static/wal.html">log de transações (WAL)</a>, acelerando e muito a inserção de registros na mesma.<br /><br />Assim cada processo disparado pelo script gera e escreve em uma unlogged table os dados, e junto com os processos de trabalho (workers) implementei um processo especial que serve com um tipo de coletor de lixo (garbage collector) para ir gradativamente lendo os lotes processados (unlogged tables geradas) e inserindo (com copy claro) na partição de destino.<br /><br />Com essa estratégia posso ter um certo nível de escala na escrita pois consigo separar as tabelas em tablespaces distintas. Claro que se algum imprevisto ocorrer, tipo um desligamento não previsto do servidor, o próprio script tem habilidade de detectar essa situação e fazer uma limpeza geral antes de inicar um novo processo, até mesmo porque as unlogged tables tem seu conteúdo eliminado nessas situações, e não queremos perder parte dos registros não é mesmo... :-)<br /><br /><h4>Finalizando...</h4>Resumindo o que fiz foi:<br />- Particionar uma tabela grande em outras menores<br />- Planejar o processamento dividindo em lotes menores para poder fazer processamento paralelo<br />- Utilizar unlogged tables para receber os dados oriundos dos lotes que são processados em paralelo<br />- Implementar um processo que irá ler os lotes já processados e inserir os registros na partição de destino.<br /><br />Existem outras coisas que foram feitas para melhorar o desempenho, tipo desligar o autovacuum nas tabelas, aumentar o work_mem, criar índices necessários ao final do processamento, e outros que podem ser feitos e que vcs podem visualizar neste <a href="http://savepoint.blog.br/acelerando-a-importacao-de-dados-no-postgresql/">post do Fábio</a>.<br /><br />Bom, se vc chegou até aqui então obrigado pela paciência e se quiser mais informações fico a disposição.<br /><br /><br />---<br />Fabrízio de Royes Mello<br />fabriziomello [at] gmail.com<br /></div>


<h2>Comments</h2>


<div class='comments'>
<div class='comment'>
<div class='author'>Fabrízio de Royes Mello</div>
<div class='content'>
Há mto tempo atrás (Ago/2009), segui as instruções contidas em [1] para se cadastrar no Planeta (enviei email e td mais), porém nada aconteceu... nenhuma resposta, retorno, nada... :-(<br /><br /><br />[1] http://wiki.postgresql.org.br/PlanetaPostgreSQLBR</div>
</div>
<div class='comment'>
<div class='author'>Unknown</div>
<div class='content'>
O artigo ficou muito massa. Só tem uma coisa que me preocupa aqui.... qual o motivo do seu blog ainda não estar no nosso planeta.postgresql.org.br ???</div>
</div>
</div>

]]></content>
  </entry>
  
</feed>
